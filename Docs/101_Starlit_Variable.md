# 변수와 연산자

- Starlit 언어에서 변수와 연산자의 사용법을 정리한 문서
- 계수기용 Starlit은 복소수를 따로 사용하지 않으므로 `int`형과 `float`형 위주로 다룬다.

# 1. 변수의 선언과 대입

## 1.1. 변수의 선언

- 변수의 선언은 `#변수명(초기값):자료형;`으로 적고, 초기화 없이 선언만 하려면 초기값을 비워 두면 된다.
  - 예1 : `#a():int;` : 정수 `a`를 선언만 하고, 초기화하지 않음.
  - 예2 : `#a(0):int;` : 정수 `a`를 0으로 초기화함과 동시에 선언.
 
- 소수의 선언은 아래와 같이 할 수 있다. 이때, 정수를 넣으면 값이 깨지니 유의하자.
  - 예3 : `#b():float` : `b`를 소수로 선언하고, 초기화하지 않음.
  - 예4 : `#b(3.14):float` : `b`를 소수로 선언하고, 3.14로 초기화
  - 예5 : `#b(1):float` : `b`를 소수로 선언하고, ~~1로 대입~~이상한 값이 대입된다.

## 1.2. 변수의 대입

- 대입 연산자 `=`를 사용하여 간단하게 변수에 값을 대입할 수 있다.
  - 예1 : `a = 3.14;` : a가 소수인 경우 3.14를 대입, 정수인 경우 3.14를 형변환해서 정수 3이 대입.
  - 예2 : `a = 0;` : a가 선언되지 않은 경우 초기화된 값의 유형을 따라 **자동으로 선언**. 왼쪽의 경우 a는 정수형이 되고, 0으로 초기화됨.
 
# 2. 연산자

## 2.1. Starlit의 연산자

- 연산자가 너무 많이 정의되어 있어 C에서도 쓰는 중요한 연산자 위주로 정리한다.

- 단항 연산자

  |기호|명칭|기능|우선순위|
  |--|--|--|--|
  |`+`|`$plus`|양수를 의미하는 부호(잘 쓰이지 않음)|1|
  |`-`|`$minus`|음수를 의미하는 부호|1|
  |`!`|`$not`|논리 부정|1|
  |`^`|`$bnot`|비트 부정(반전)|1|
  |`*`|`$star`|~~포인터~~[^포인터]|1|

- 2항 연산자

  |기호|명칭|기능|우선순위|
  |--|--|--|--|
  |`~`|`$rand`|~~난수~~[^난수]|2|
  |`^^`|`$exp`|~~웃음 연산~~지수 연산[^지수]|3|
  |`*`|`$mul`|곱셈 연산|4|
  |`/`|`$div`|나눗셈 연산|4|
  |`//`|`$div2`|나눗셈 연산[^음수]|4|
  |`%`|`$mod`|나머지 연산[^정수]|4|
  |`%%`|`$mod2`|나머지 연산[^음수나머지]|4|
  |`+`|`$add`|덧셈|6[^5순위가아닌이유]|
  |`-`|`$sub`|뺄셈|6|
  |`<<`|`$shl`|비트 Shift 왼쪽방향|7|
  |`>>`|`$shr`|비트 Shift 오른쪽방향|7|
  |`<<<`|`$shl2`|~~비트 Shift 왼쪽방향~~[^베릴로그]|7|
  |`>>>`|`$shr2`|~~비트 Shift 오른쪽방향~~[^베릴로그]|7|
  |`<`|`$lt`|비교 연산(less than)|8|
  |`>`|`$bt`|비교 연산(bigger than)|8|
  |`<=`|`$le`|비교 연산(less or equal)|8|
  |`>=`|`$be`|비교 연산(bigger or equal)|8|
  |`==`|`$eq`|양쪽이 모두 같은지 확인|9|
  |`!=`|`$ne`|양쪽이 다른지 확인|9|
  |`&`|`$band`|비트 AND|10|
  |`^`|`$bxor`|비트 XOR|11|
  |`\|`|`$bor`|비트 OR|12|
  |`&&`|`$and`|논리 AND|13|
  |`\|\|`|`$or`|논리 OR[^XOR이 없는 이유]|14|
  |`=`|`$put`|대입[^오버로딩]|16[^15순위가아닌이유]|
  
## 2.2. 대입 연산자

- Starlit은 C++과는 다르게 대입 연산자는 오버로딩할 수 없게 되어 있다. 따라서 만약 덧셈 연산 `+`를 정의한다면 자동으로 `+=`연산도 정의된다.
- `+`가 정의된다면 `a+=2`는 `a=a+2`와 완벽히 같다.

## 2.3. 예시

- 사칙연산
  - `3+2` == `5`
  - `3-1` == `2`
  - `8*7` == `56`
  - `9/3` == `3`
  - `10.0/3` == `3.33`
  - `32%3` == `2`
  - `-10%3` == `-1`
  - `-10%%3` == `2`
 
- 비트 연산
  - `0x01<<3` == `0x08`
  - `0b00000001 << 4` == `0b00010000`
  - `0b01101101 & 0b11110000` == `0b01100000`
  - `0b01101101 | 0b11110000` == `0b11111101`
  - `0b01101101 ^ 0b11110000` == `0b10011101`

- 비교 연산
  - `3>2` == `True`
  - `3==2` == `False`
  - `3<2` == `False`
  - `3>3` == `False`
  - `3==3` == `True`
  - `3>=3` == `True`
 

[^포인터]: Starlit에서는 포인터라는 개념이 없고, 레퍼런스라는 개념이 있다.
[^난수]: Starlit3부터는 난수 연산자가 사라지고, Random함수를 사용한다. ~~연산자 오버로딩만 쓰면 잘만 쓸 수 있다.~~
[^지수]: XOR 연산자로서의 ^와의 충돌을 피하기 위해 ^^로 정의했다. 정수, 소수, 복소수 모두 사용 가능.
[^음수]: 수학적인 의미에서의 몫을 얻을 때 사용한다. (-1)//3은 0이 아닌 1이다.
[^정수]: 정수에서만 정의되는 연산.
[^음수나머지]: 음수의 나머지에 대해서도 보정한 값을 출력. -1을 4로 나눈 나머지는 1이 아닌 3이다. -1도 아니다.
[^5순위가아닌이유]: 곱셈과 덧셈 사이에 의문의 연산자가 존재한다.~~복소수 다룰때 상당히 유용해보이는 연산인 걸로 알고 있다.~~
[^베릴로그]: Verilog에서 볼 수 있는 연산인데, Arithmatic Shift와 Logical Shift의 구분이 있다.
[^XOR이 없는 이유]: XOR은 !=로 대체 가능해서 따로 정의하지 않는다. Bool함수를 사용해 Bool로 만든 뒤 사용하면 된다.
[^오버로딩]: 대입은 오버로딩을 따로 정의하지 않는다. 자동으로 대입 기능이 생성되기 때문이다.
[^15순위가아닌이유]: 이상한 연산자가 15순위에 더미 데이터로 남아 있다.
