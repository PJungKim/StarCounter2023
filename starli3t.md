# Starlit 3.0

- Pierre de starlit이라는 사람이 만들었다고 알려진 STM32계열 임베디드 제어를 목적으로 만든 프로그래밍 언어.
- 정식 명칭은 Starlit이지만, 절대로 스탈릿이라 읽지 않고 스타라이트라고 읽는다(...)
- 절대 Starlight가 아니다! 원래는 Starlight였으나 동명의 다른 프로그래밍 언어가 있어서 Starlit으로 변경했다고. ~~그러나 읽을 때는 Starlight라고 읽는다.~~

## 1. 역사

### 1.1. Dot Project

- 2019년, LED 매트릭스를 제어하는 코드를 만들어보자고 한데서 제작한 언어.
- 현재 남아있는 역사적 자료(?)는 거의 없다.
- 문법이 상당히 충격적이다. 매개변수를 ,로 구분하지 않는건 덤.
- 의외로 논리회로 설명할때 이만한게 없었다고는 한다.~~도대체 어떤 언어를 참고하고 만들었길래 이모양인걸까~~

### 1.2. Starlit 2

- AVR에 적용하기 위해 제작한 언어.
- Starlit 2까지는 정수형 변수만 사용이 가능했다. 당연히 구조체 따윈 지원하지 않았고, 객체지향도 아니었다.
- Dot Project를 C언어 형식으로 바꾼 언어라는 특징이 남아있는데, 변수 선언법이 `#변수명(값)`이고, 이에 대한 포인터가 `_변수명`이었다.
- 여기까지는 논리회로용 기상천외한 연산자가 많이 존재했다. 그래서인지 그런 연산자가 지금까지 빈칸으로 남아 있어서 주석 달때도 `///`, `/**` 등으로 3자리를 쓴다.
- 연산자 중에 [len]과 같이 영어가 들어가는것도 있었다. 하지만, 현재는 이런 연산자가 함수명 정의로 남게 되었다.

### 1.3. Starlit 3

- STM32에 적용하기 위해 제작한 언어.
- 정수형 변수 기반이라 기초변수는 정수형 하나만 제공되지만, 형 이름만 다르게 해서 소수 연산을 하면 소수, 그걸 여러개 붙이면 LONG형 변수 등을 구현할수 있다는 점을 참조해 자료형 개념 없이 완전 객체지향으로 만들었다. 그래서 이 언어에서는 자료형과 클래스는 동일하게 취급한다!
- 객체의 속성으로서 구조체를 제공한다. 또, 메소드 기능도 제공된다.
- 연산자 오버로딩 기능에 매우 최적화되어 있다. 완전 자유형으로 오버로딩할 수 있다![^1]
- 여느 객체지향 언어가 다 그렇듯 포인터를 제공하지 않는다! 즉, 포인터 사용이 제한적이다. 굳이 포인터 기반으로 쓰고싶다면 레퍼런스에 형변환 연산자를 써서 사용해야 한다.

### 1.4. 향후 계획

- Starlit 4는 더 이상 출시되지 않을 가능성이 높다. 단, 프로세서에 맞는 가상머신만 구현하면 단일 컴파일러로 모두 쓸 수 있을 예정이다.

## 2. 문법

### 2.1. 비교적 자유로운 문법
- Starlit 3는 2 시절부터 전통적으로 C보다 더한 자유도를 제공하였는데, 공백 문자는 모두 지우고 보는 블랭크 리젝터(?)가 있기 때문이다.
- 3 시절은 2 시절보다 더한데, 2 시절은 줄바꿈 규정이 존재해 세미콜론을 안 쓸 수 있었으나 3 시절은 그마저도 삭제되어 세미콜론 규정이 빡세졌다. 사실 Dot Project에서 세미콜론이 금지되어서 그런거라고. 그래서 2 시절에도 세미콜론은 권장사항이었다.
- 띄어쓰기, 줄바꿈 등을 무시하는 특성상 띄어쓰기를 제거했을때 같으면 같은것이니 사용 시 주의를 요한다. 이를테면 `No won`과 `Now on`은 같은 레이블이다!

#### 2.1.1. 괄호, 세미콜론에 엄격한 문법

- 지나친 자유도로 인해 중의적인 해석을 막기 위해 괄호, 세미콜론 등이 엄격하게 적용된다.
- Starlit 2와는 달리 세미콜론은 의무이다.
```
if(a==0)
    matrix1.Print("XX") with (RED1);
```
- 위의 형태로 작성하면 컴파일 오류가 난다.
- 당연하다면 당연하겠지만, 괄호 한두개 빼먹으면 오류가 난다. 단, 함수 단위 컴파일하기 때문에 간혹 괄호 제대로 닫지 않았음에도 컴파일이 제대로 되는 경우도 있어서 주의를 요한다.


### 2.2. 변수의 정의 및 사용
- `#변수명(초기값):자료형` : 변수를 선언한다.
  - 전역변수: 함수 바깥쪽에 정의하면 전역변수이며, 상수로 최적화되도록 정의해야 한다.
  - 지역변수: 함수 안쪽에 정의하면 지역변수이다.
  - 초기값 결함 문제: 초기값 자리에는 다양한 형태가 올 수 있다보니 형변환 하지 않고 넣으면 자동 형변환해준다는 보장이 없다(...) 이 문제는 어째서인지 제작자가 **해결하려고 하지 않고 있다!**

- 변수의 사용: 변수앞에 # 붙이지 않은 상태로 쓴다.

#### 2.2.1. 변수 작명 규칙

  - 변수는 숫자, 문자, _로만 구성할 수 있다.[^2]
  - 숫자, _로 시작할 수 없다.[^3]

#### 2.2.2. 배열

  - 정수형 배열 정의

```
#arr(int(0, 1, 2, 3)):int[4];
```

  - 배열로 정의할 때는 자료형 뒤에 크기를 적는다.
  - 고차원 배열은 `int[2,4]`의 형태로 정의한다.
  - 지역변수로만 초기화 가능하다. 물론 저런 식으로 초기화하면 상당히 복잡하므로 반복 연산자로 초기화하길 권장한다.

#### 2.2.2.1. 배열 초기화 팁?

규칙성 있는 형태라면 반복 연산자를 잘 써먹어보자.

```
arr[i:0:3] = i;
```

#### 2.2.3. 여담

  - Starlit 2 시절에는 변수 앞에 #을 붙일 수 있었다. 이는 Dot Project 시절 변수명 앞에 _를 붙인것과 안 붙인것은 동일하다는 규칙이 #으로 바뀐 것이고, _가 포인터 개념이 되었기 때문.
  - Dot Project 시절은 `'A'`의 형태가 문자 상수임과 동시에 포인터 기능도 하였다! 그 시절에는 지역변수라는 개념이 없었고, 전역변수 역시 1자리의 문자로 썼기 때문. 그래서 변수명이 +일 수도 있었다! 다만, 실제로 _+로 써야 했지만(...)


### 2.3. 연산자

- Starlit 언어가 정수형만 쓰던 시절, 소수처럼 쓰는 기능, 논리회로로 쓰는 기능 등 기상천외한 용도로 쓰기 위해 이상한 연산자가 많다. 그래서 Starlit 3에서는 연산자 자체는 정의되어있는데, 그 연산자에 대한 함수가 정의되어 있지 않아서 함수 미정의 오류가 나기도 한다!

#### 2.3.1. 연산자 우선순위

  - 통상적인 연산자의 우선순위는 C와 거의 같다.

#### 2.3.2. 3항 연산자

  - `?`, `:`가 다른 용도로 쓰이는 특성상 `?:` 연산자는 없다!
  - 이 연산자와 같은 기능을 하는 함수라면 `if(조건,A,B)` 또는 `(A)if(조건)else(B)` 정도가 된다.
  - Starlit은 괄호에 엄격하기 때문에 위의 수식에서 괄호를 빼면 `Aif조건elseB`라는 변수로 인식하고, 컴파일 오류가 나니 주의하자. **파이썬과는 다르다!**

#### 2.3.3. 문자열

  - 파이썬과 C++을 짬뽕한 듯한 문자열 연산 방식이 특징이다.
```
main(){
    OLED_cout << "Result: %d" % result << "\n"
}
```

|연산자|기능|
|------|------|
|<<|출력 매체에 문자 출력|
|+|문자열 이어붙이기[^4]|
|%|문자열에 값 넣기[^5]|

#### 2.3.3.1. +연산과 <<연산의 차이
- `+` 연산자는 문자열 객체에 이어붙인 문자열을 얻을 수 있다. 때문에 앞 문자열의 마지막 색상 정보를 이어받는다. 하지만, 문자열 길이가 길어지면 오작동할 수 있다.
- << 연산자는 이어서 출력한다. 때문에 앞 문자열의 색상 정보가 초기화된다. 그러나 문자열 길이가 합쳐서 256자가 넘어가도 멀쩡히 작동한다. ~~그정도 길이면 OLED가 다 출력 못하기 때문에 무조건 잘린다.~~

#### 2.3.4. 반복 연산자

- `:`는 그 자체로 반복 연산자로 사용되며, 그 어떤 연산자보다도 우선순위로 작동한다.
- 지나친 반복 연산자의 남용은 속도 저하를 유발하니 필요한 때에 쓰는 것을 추천한다.
- `:`는 잘 쓰면 삼각형 반복 연산같은 기상천외한 연산도 쓸 수 있다!
- 반복변수 : `i:0:7`과 같이 정의하면 i는 반복변수로 쓸 수 있다. 어느 한 곳에 반복변수를 정의하면 그 문장에 있는 모든 i를 이 규칙으로 쓴다.
- 반복 연산자는 정수만 지원되며, 시작점부터 끝점까지 1씩 증가하며 반복된다. 따라서 2배 증가 등의 형태로 쓰려면 반복변수를 곱하는 방식으로 써야 한다.

### 2.4. 조건문 반복문

#### 2.4.1. 조건문

```
if(a == 0) {
    matrix1.Print("NA") with (RED1);
}
elif(a == 255) {
    matrix1.Print("XX") with (YELLOW1);
}
else{
    matrix1.Print("%02X" % a) with (BLUE1);
}
```

- 조건문에는 `if`, `elif`, `else`가 있다. studio에 `elseif`가 정의되어 있으면 `else if`도 사용 가능하다.
- Starlit 3이 괄호에 매우 엄격하기 때문에 `else if` 사용은 원칙상 허용하지는 않는다. C에서는 `else` 다음의 첫 문장은 `else`에 해당하는 구문으로 처리하지만, starlit에서는 `elseif`라는 구문으로 처리해 정의되어 있지 않으면 오류가 난다.

#### 2.4.2. 반복문

```
while(1){
    if(BUTTON_Read()){
        break(2);
    }
}
```

- 반복문에는 `while`이 있으며, 반복문을 빠져나가기 위해 `break`문을 사용한다. while문은 조건이 만족될 때까지 계속 반복하는 구문이다.
- 특이하게도 break문도 인자가 있는데, 2가 있으면 중괄호 2개를 빠져나가라는 뜻이다. c에서의 goto를 쓰지 못하도록 만든 문법이다. 그러니 Goto는 생각도 하지 말자.

#### 2.4.2.1. for문

- while문을 야매로 조종해서 만든 구문이다.
```
for(i = 0, i < 10, i += 1){
    matrix1.Print("%02d" % i) with (RED1);
    Delay(1000);
}
```
- 위와 같은 구문은 LED 매트릭스에 1초 간격으로 0부터 9까지[^6] 출력한다.
- i가 for문을 사용하기 전에 정의되어 있어야 한다. 따라서 for문 앞에 `#i():int;`를 붙여 준다.
- 절대 for문 안에 세미콜론을 넣지 말자. for문 자체가 토막나서 컴파일 오류가 난다.
```
for(i) from (0) to (9){
    matrix1.Print("%02d" % i) with (RED1);
    Delay(1000);
}
```
- 1씩 증가하는 for문은 위와 같이 나타낼 수도 있다.

#### 2.4.2.2. do...while문?

- 결론부터 말하면 그런 거 없다.
```
{
    ...
    if(a == 0){
        again(2);
    }
}
```
- do...while문 구현하기 위해 again문을 사용할 수는 있다. 애초에 그러려고 만든 게 저 구문이라고.
- again 대신 continue를 써도 똑같이 작동한다.[^7]

#### 2.4.2.3. 반복문 빠져나가는 방법

- 아래의 구문은 빠져나갈 중괄호 수를 **상수로** 적어야 한다.
    - `break` : 무조건 반복문을 빠져나간다.
    - `continue` : 반복문의 조건으로 돌아가서 조건이 맞으면 계속 반복, 조건이 맞지 않으면 빠져나간다.
    - `again` : 반복문을 처음부터 다시 실행한다.[^8]

- 아래의 구문은 함수 전체를 빠져나간다.
    - `return` : 함수 전체를 빠져나간다.[^9]
 
### 2.5. 함수

#### 2.5.1. 함수의 정의

```
funcname(arg1:class1, ..., arg9:class9):returnClass{
    ...
    return(returnValue);
}
```
[^10]

- 함수의 정의는 위와 같이 한다.
- 매개변수는 `변수명:자료형`의 꼴로 정의한다. C언어와는 다른 형태.
- 당연하지만, 값을 반환하는 함수는 return을 꼭 넣어주자.

```
funcname(arg1:class1, ..., arg9:class9){
    ...
}
```

- void형 함수는 뒤에 자료형을 명시하지 않으면 된다. 절대 void형이라고 붙이지 말자!

#### 2.5.2. 함수명

- 함수명 역시 변수와 똑같은 규칙을 적용한다.
    - 영어, 숫자, _만을 사용하되, 숫자나 _로 시작하면 안 된다.
 
- `_(변수)`의 형태의 함수는 인자의 포인터를 의미한다.
- 이중 함수명을 허용한다. 이를테면 `Print text (txt:ref) from (idxStart:int) to (idxStart:int)`와 같은 함수도 쓸 수 있다.[^11]
    - 그렇다고 파이썬처럼 `Print text "Hello World!" from 0 to 8`과 같이 쓰면 오류가 난다. 꼭 괄호가 쳐진 부분은 괄호를 씌우자!

#### 2.5.2.1. 풀네임

- 함수명 중복 방지를 위해 함수 자체를 변수로 쓸 때는 풀네임을 사용해야 한다.
- 풀네임 규칙
    - `func(a:int)`는 int형 변수를 매개변수로 갖는 func이라는 의미에서 `func$int`가 풀네임이 된다.
    - `func(a:int)with(b:int)`는 int형 변수를 매개변수로 갖는 func + int형 변수를 매개변수로 갖는 with의 조합으로 풀네임은 `func$int$with$int`이다.
    - 따라서 함수명을 정의할 때는 class와 중복되어서는 안 된다.[^11]

#### 2.5.2.2. 연산자 오버로딩

- 함수명을 특정한 형태로 정의하면 연산자 오버로딩으로 쓸 수 있다.
- 연산자 오버로딩으로 사용되는 함수명은 언제나 `$`으로 시작한다.

- 단항 연산자    

|연산자|오버로딩 함수명|우선순위|
|------|---------------|--------|
|`+`|$plus|2|
|`-`|$minus|2|
|`!`|$not|2|
|`~`|$bnot|2|
|`*`|$star|2|

- 이항 연산자    

|연산자|오버로딩 함수명|우선순위|
|------|------|----|
|`~`|$rand|2|
|`~~`|$rand2|2|
|`^^`|$exp|3|
|`^_^`|$smile|3|
|`*`|$mul|4|
|`/`|$div|4|
|`%`|$mod|4|
|`**`|$mul2|4|
|`//`|$div2|4|
|`%%`|$mod2|4|
|`/%`|$dmod|4|
|`***`|$mul3|4|
|`<>`|$diamond|4|
|`><`|$cross|4|
|`*+`|$polar|5|
|`+*`|$hypot|5|
|`/*`|$divmul|5|
|`*/`|$muldiv|5|
|`+`|$add|6|
|`-`|$sub|6|
|`++`|$add2|6|
|`--`|$add2|6|
|`+++`|$add3|6|
|`---`|$add3|6|
|`<<`|$shl|7|
|`>>`|$shr|7|
|`<<<`|$shl2|7|
|`>>>`|$shr2|7|
|`<=`|$le|8|
|`=<`|$el|8|
|`<`|$lt|8|
|`>=`|$be|8|
|`=>`|$eb|8|
|`>`|$bt|8|
|`==`|$eq|9|
|`!=`|$ne|9|
|`===`|$eq2|9|
|`!==`|$ne2|9|
|`&`|$band|10|
|`^`|$bxor|11|
|`\|`|$bor|12|
|`&&`|$and|13|
|`\|\|`|$or|14|
|`=-=`|$res|15|
|`=-`|$cas|15|
|`\|-`|$switch|15|
|`/-`|$swotch|15|
|`=`|$put|16|

~~대체 ^_^는 어디서 주워온 연산자인가?~~
~~15순위 연산자는 참 괴상하다.~~
~~대체 swotch는 어느나라 단어야!!~~
- 보면 알겠지만, 정수만 쓰던 시절의 연산자가 그대로 남아서 저렇게 많은 것이다.

### 2.6. 객체 및 클래스


### 2.7. 주요 파일

#### 2.7.1. import와 studio

- $import를 이용하여 파일을 참조할 수 있다. 만약 서로 다른 파일이 서로를 참조해서 중복되는 경우, 자동으로 1번만 참조하도록 하였다. 즉, Pragma once가 패시브로 작동한다.
- starlight가 설치된 디렉토리에서는 형식 없이 파일명만 입력하면 자동 참조된다. 그 외의 경우, 파일 형식을 포함해서 입력해야 한다.
    - `$import(studio)`는 기본으로 넣는다. 만약 studio가 아닌 다른 파일을 기본 함수 파일로 사용한다면, 그 파일에 따라 문법이 정해진다고 생각하면 된다.
    - studio 파일은 정수의 연산을 포함하여(!?) **모든 문법이 저장되어 있다!**
    - 계수기에서는 stucnt 파일이 studio 역할을 한다.
    - 프로세서에 따라 studio가 다르며, 거기에 맞는 studio를 써야 한다.
        - 같은 프로세서여도 용도에 따라 studio가 달라진다.


## 3. 예제

### 3.1. Hello, World! 출력하기

#### 3.1.1. OLED에 출력하기 정석코드

```
main(){
    OLED_cout << "Hello, World!" << "\n";
    while(!BUTTON_Read()){}
}
```
- while문에서 아무것도 실행하지 않더라도 중괄호를 써야 한다. 그정도로 괄호는 매우 민감하다. **C언어와 달리 절대 세미콜론은 문장이 아니다.**
- 버튼 입력 함수가 없으면 OLED에서 잠깐 Hello, World!가 번쩍였다 꺼질 수 있으므로 버튼을 눌러 프로그램을 종료하게 설계한다.

#### 3.1.1.1. 다른 방식으로 출력하는 경우
```
main(){
    OLED_Print("Hello, World!\n");
    while(!BUTTON_Read()){}
}
```
- 이 방법으로도 출력할 수는 있지만, 상당히 불편하다.

#### 3.1.2. LED Matrix Display에 출력하는 경우 - 계수기
```
main(){
    matrix1.Print("Hello, World!");
    while(!BUTTON_Read()){}
}
```
- 계수기의 전광판은 위와 같이 전송만 하면 자체적으로 스크롤 방식으로 출력한다. 따라서 OLED_Print자리에 함수만 바뀐 것을 알 수 있다.

### 3.2. LED 전광판에 2자리 수 출력하기 - 계수기
```
main(){
    matrix1.Print("%02d" % 23) with (RED1);
    while(!BUTTON_Read()){}
}
```
- 2자리 수 출력 함수는 위와 같이 주어지며, 위 코드는 숫자 23을 출력하는 예제이다.

#### 3.2.1. LED 전광판에 버튼을 눌렀을 때 증가 또는 감소하는 함수
```
main(){
    #sw():int;
    #no(0):int;
    matrix1.Print("%02d" % no) with (YELLOW1);
    while(1){
        sw = BUTTON_Read();
        if(sw == BUTTON_1){
            no = (no + 1) %% 100;
            matrix1.Print("%02d" % no) with (YELLOW1);
        }
        elif(sw == BUTTON_2){
            no = (no - 1) %% 100;
            matrix1.Print("%02d" % no) with (YELLOW1);
        }
    }
}
```
- 버튼을 누르면 sw 변수에 0이 아닌 값이 저장되며, 값을 감지하면 숫자가 바뀌는 예제이다.

## 4. 여담

- 가장 기본적으로 추가하는 파일은 studio이다. **절대 stdio가 아니다!** STarlight Universal Digital Input and Output의 약자이다. 즉, 스타라이트 언어의 모든 문법이 정의되어 있고, 디지털 임베디드 시스템에 맞게 나온 입출력 파일이다. stdio와는 전혀 차원이 다르지만, C언어에서의 stdio 지위를 가진다!
    - 물론, studio 자체는 역 두문자어가 맞긴 하다. 애초에 저 이름을 지은게 C언어에서 stdio를 studio라고 적는 실수를 많이 하는 것을 지켜본 나머지 아예 헷갈릴 여지가 없게 studio라고 이름 붙인 것.
    - 그러나 C언어보다도 더한 것은, studio 파일이 없으면 **덧셈 연산조차 정의가 되지 않는다!** 즉, 모든 문법을 정의한 Universal I/O 파일이다! 마음만 먹으면 `-` 연산자를 덧셈으로 언제든지 쓸 수도 있다! ~~상당히 변태스럽다.~~
    - 그렇다고 해서 연산자 우선순위, 괄호 문법은 studio에서도 정의할 수 없을 정도로 기본 규정으로 정의하고 있다. 그런데 연산자 우선순위도 studio에서 정의하려고 했다가 무산되었다. ~~그러나 마음만 먹으면 매크로 구문 하나 만들어서 연산자 우선순위와 연산자 그 자체도 정의하게 만들어버릴 지도 모른다!~~

- 마음만 먹으면 언제든지 한글화할수도 있으며, 실제로, 스타라이트 문법들을 모조리 한글 패치해서 스튜디오 파일을 만들었던 적도 있었다. 아마 그때가 Starlit 2 시절일 것이다.

[^1]: 단, 다른 객체지향언어와는 다르게 연산자 오버로딩을 클래스의 메소드와는 다르게 취급하므로 절대 A.add형식으로 정의하면 안된다!
[^2]: 특이하게도 $도 사용할 수 있다. 단, 암묵의 룰세 의해 사용하지 않을 뿐이다. 함수의 경우 $는 매개변수 유형을 의미할 수도 있어서 중의적인 상황이 될 수 있기에 더더욱 안 쓴다.
[^3]: C와는 다르게 **_로도 시작하면 안 된다!** _ 그 자체가 레퍼런스를 의미하기 때문. Dot Project 시절부터 전해 내려왔다(...)
[^4]: 그거 때문에 레퍼런스 2개를 더하면 문자열 객체가 튀어나온다(!) 주의할 점은 문자열 그 자체는 256자까지만 지원되므로 아무 레퍼런스 더했다가 하드폴트 당하지 말자.
[^5]: 문자열 안에 `%d` 같은거 있으면 그 자리에 넣는 식. 단, 2개 이상 동시에 쓸 수 없으니 주의하자. 2개 이상 쓸거면 + 연산자를 써서 이어붙인다.
[^6]: C언어와 같이 조건에 맞지 않는 순간 반복문을 탈출한다.
[^7]: again은 continue와는 다르게 앞에 조건이 붙어 있어도 처음부터 실행한다. continue는 조건을 판별한다. 그러나 저 구문은 중괄호 앞에 조건이 붙어 있지 않으므로 둘 다 상관 없다.
[^8]: again의 성질이 상당히 강력하다보니 반복문이 아닌 코드를 반복문처럼 쓸 수 있다! 너무 강력한 나머지 for문의 증가 기능도 무시한다는 이야기가 있다. ~~컴파일러를 만든지 너무 오래 돼서 맞는지는 모른다.~~
[^9]: C언어의 return문을 들여왔기 때문에 반환값을 인수로 넣을 수 있다. 단, void형 함수는 반환값을 넣지 않는다.
[^10]: 당연하지만, 매개변수가 꼭 9개여야 하는 것은 아니다.
[^11]: 매크로와는 다르게 매개변수가 맨 앞에 오는 형태로 정의하는 것은 불가능하다.
[^12]: 만약 class와 중복되면 출력 유형은 반드시 그 class여야 한다. 형변환 소스로 쓸 함수를 의미하기 때문이다.
